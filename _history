{"entries":[{"timestamp":1743441148517,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"http"],[-1,"s://developers.google.com/blockly/xml\"><variables></variables><block type=\"function_definition\" x=\"56\" y=\"29\"><mutation name=\"getDistance\" functionid=\"Ro#D!`?5rr[Vr_?j{O^k\"></mutation><field name=\"function_name\">getDistance</field><statement name=\"STACK\"><block type=\"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation><value name=\"RETURN_VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters</field></block></value></block></statement></block><block type=\"function_definition\" x=\"425\" y=\"20\"><mutation name=\"turnLeft\" functionid=\"r5{^]}01D(h%NJu,#PE6\"></mutation><field name=\"function_name\">turnLeft</field><statement name=\"STACK\"><block type=\"CutebotPro_pwmCruiseControl\"><value name=\"speedL\"><shadow type=\"math_number\"><field name=\"NUM\">-40</field></shadow></value><value name=\"speedR\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">90</field></shadow></value></block></next></block></statement></block><block type=\"device_button_event\" x=\"52\" y=\"222\"><field name=\"NAME\">Button.A</field"],[1,"://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\""],[0,"></b"]],"start1":12,"start2":12,"length1":1397,"length2":103},{"diffs":[[0,"</block>"],[1,"\n"],[0,"</xml>"]],"start1":112,"start2":112,"length1":14,"length2":15}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"function turnLeft() {\n    CutebotPro.pwmCruiseControl(-40, 40)\n    CutebotPro.angleRunning(CutebotProWheel.AllWheel, 330, CutebotProAngleUnits.Angle)\n}\n\nfunction getDistance(): number {\n    return CutebotPro.ultrasonic(SonarUnit.Centimeters)\n}\n\ninput.onButtonPressed(Button.A, function on_button_pressed_a() {\n    turnLeft()\n})"],[0,"\n"]],"start1":0,"start2":0,"length1":328,"length2":1}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," \"*\""],[-1,",\n        \"pxt-cutebotpro\": \"github:elecfreaks/pxt-cutebot-pro#v2.1.0\""],[0,"\n   "]],"start1":138,"start2":138,"length1":78,"length2":8},{"diffs":[[0,".md\""],[-1,",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\""],[1,"\n    ],\n    \"additionalFilePaths\": []"],[0,"\n}\n"]],"start1":222,"start2":222,"length1":64,"length2":44}]},{"type":"added","filename":"main.py","value":"def turnLeft():\n    CutebotPro.pwm_cruise_control(-40, 40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\ndef getDistance():\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS)\n\ndef on_button_pressed_a():\n    turnLeft()\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n"}]},{"timestamp":1743441743130,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0," x=\""],[-1,"337"],[1,"56"],[0,"\" y=\""],[-1,"-38"],[1,"29"],[0,"\"><m"]],"start1":111,"start2":111,"length1":19,"length2":17},{"diffs":[[0,"ation name=\""],[-1,"turnLeft"],[1,"getDistance"],[0,"\" functionid"]],"start1":130,"start2":130,"length1":32,"length2":35},{"diffs":[[0,"tionid=\""],[-1,"Vz5/;1m(W;THC`HkdqP2"],[1,"Ro#D!`?5rr[Vr_?j{O^k"],[0,"\"></muta"]],"start1":159,"start2":159,"length1":36,"length2":36},{"diffs":[[0,"n_name\">"],[-1,"turnLeft"],[1,"getDistance"],[0,"</field>"]],"start1":220,"start2":220,"length1":24,"length2":27},{"diffs":[[0,"pe=\""],[-1,"CutebotPro_pwmCruiseControl\""],[1,"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation"],[0,"><va"]],"start1":280,"start2":280,"length1":36,"length2":106},{"diffs":[[0,"me=\""],[-1,"speedL"],[1,"RETURN_VALUE"],[0,"\"><s"]],"start1":392,"start2":392,"length1":14,"length2":20},{"diffs":[[0,"UM\">"],[-1,"-4"],[0,"0</f"]],"start1":451,"start2":451,"length1":10,"length2":8},{"diffs":[[0,"ow><"],[-1,"/value><value name=\"speedR\"><shadow type=\"math_number\"><field name=\"NUM\">40"],[1,"block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters"],[0,"</fi"]],"start1":470,"start2":470,"length1":83,"length2":77},{"diffs":[[0,"meters</field></"],[-1,"shadow"],[1,"block"],[0,"></value><next><"]],"start1":537,"start2":537,"length1":38,"length2":37},{"diffs":[[0,"ue><"],[-1,"next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field"],[1,"/block></statement></block><block type=\"function_definition\" x=\"425\" y=\"20\"><mutation name=\"turnLeft\" functionid=\"r5{^]}01D(h%NJu,#PE6\"></mutation><field name=\"function_name\">turnLeft</field><statement name=\"STACK\"><block type=\"CutebotPro_pwmCruiseControl\""],[0,"><va"]],"start1":564,"start2":564,"length1":181,"length2":264},{"diffs":[[0,"l\"><value name=\""],[-1,"angle"],[1,"speedL"],[0,"\"><shadow type=\""]],"start1":822,"start2":822,"length1":37,"length2":38},{"diffs":[[0,"UM\">"],[-1,"33"],[1,"-4"],[0,"0</f"]],"start1":887,"start2":887,"length1":10,"length2":10},{"diffs":[[0,"ue><"],[-1,"next><block type=\"CutebotPro_trolleySteering\"><field name=\"CutebotProTurn\">CutebotProTurn.LeftInPlace</field><value name=\"angle\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"360\" label=\"Angle\" precision=\"0\"></mutation"],[1,"value name=\"speedR\"><shadow type=\"math_number\""],[0,"><fi"]],"start1":916,"start2":916,"length1":237,"length2":54},{"diffs":[[0,"me=\""],[-1,"SLIDER\">9"],[1,"NUM\">4"],[0,"0</f"]],"start1":976,"start2":976,"length1":17,"length2":14},{"diffs":[[0,"ue><"],[-1,"/block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"0\" y=\"0\"><mutation name=\"getDistance\" functionid=\"GK`mzhe7zP4|3%r4.EHQ\"></mutation><field name=\"function_name\">getDistance</field><statement name=\"STACK\"><block type=\"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation"],[1,"next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field"],[0,"><va"]],"start1":1009,"start2":1009,"length1":367,"length2":181},{"diffs":[[0,"value name=\""],[-1,"RETURN_VALUE"],[1,"angle"],[0,"\"><shadow ty"]],"start1":1188,"start2":1188,"length1":36,"length2":29},{"diffs":[[0,"ield name=\"NUM\">"],[1,"9"],[0,"0</field></shado"]],"start1":1236,"start2":1236,"length1":32,"length2":33},{"diffs":[[0,"ow><"],[-1,"block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters</field"],[1,"/value"],[0,"></b"]],"start1":1268,"start2":1268,"length1":84,"length2":14},{"diffs":[[0,"value></block></"],[-1,"value"],[1,"next"],[0,"></block></state"]],"start1":1273,"start2":1273,"length1":37,"length2":36},{"diffs":[[0," x=\""],[-1,"-36"],[1,"52"],[0,"\" y=\""],[-1,"164"],[1,"222"],[0,"\"><f"]],"start1":1355,"start2":1355,"length1":19,"length2":18},{"diffs":[[0,"ld><"],[-1,"statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation></block></statement><"],[0,"/blo"]],"start1":1403,"start2":1403,"length1":153,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ion turn"],[-1,"Tes"],[1,"Lef"],[0,"t() {\n  "]],"start1":5,"start2":5,"length1":19,"length2":19},{"diffs":[[0,"le)\n"],[-1,"    CutebotPro.trolleySteering(CutebotProTurn.RightInPlace, 90)\n}\n\nfunction moveTest() {\n    CutebotPro.pwmCruiseControl(40, 40)\n    CutebotPro.distanceRunning(CutebotProOrientation.Advance, 50, CutebotProDistanceUnits.Cm)\n    CutebotPro.pwmCruiseControl(-20, -20)\n    CutebotPro.distanceRunning(CutebotProOrientation.Retreat, -20, CutebotProDistanceUnits.Cm)\n"],[0,"}\n\nf"]],"start1":146,"start2":146,"length1":368,"length2":8},{"diffs":[[0,"    "],[-1,"basic.pause(500)\n    turnTest()\n    moveTes"],[1,"turnLef"],[0,"t()\n"]],"start1":310,"start2":310,"length1":51,"length2":15}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"def turn"],[-1,"Tes"],[1,"Lef"],[0,"t():\n   "]],"start1":0,"start2":0,"length1":19,"length2":19},{"diffs":[[0,"LE)\n"],[-1,"    CutebotPro.trolley_steering(CutebotProTurn.RIGHT_IN_PLACE, 90)\n\ndef moveTest():\n    CutebotPro.pwm_cruise_control(40, 40)\n    CutebotPro.distance_running(CutebotProOrientation.ADVANCE, 50, CutebotProDistanceUnits.CM)\n    CutebotPro.pwm_cruise_control(-20, -20)\n    CutebotPro.distance_running(CutebotProOrientation.RETREAT, -20, CutebotProDistanceUnits.CM)\n\n"],[0,"def "]],"start1":144,"start2":144,"length1":370,"length2":8},{"diffs":[[0,"    "],[-1,"basic.pause(500)\n    turnTest()\n    moveTes"],[1,"turnLef"],[0,"t()\n"]],"start1":251,"start2":251,"length1":51,"length2":15}]}]},{"timestamp":1743442270679,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"dvance, "],[-1,"4"],[1,"5"],[0,"0, Cuteb"]],"start1":333,"start2":333,"length1":17,"length2":17},{"diffs":[[0,"treat, -"],[-1,"4"],[1,"2"],[0,"0, Cuteb"]],"start1":470,"start2":470,"length1":17,"length2":17}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"DVANCE, "],[-1,"4"],[1,"5"],[0,"0, Cuteb"]],"start1":329,"start2":329,"length1":17,"length2":17},{"diffs":[[0,"TREAT, -"],[-1,"4"],[1,"2"],[0,"0, Cuteb"]],"start1":469,"start2":469,"length1":17,"length2":17}]}]},{"timestamp":1743442683039,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"etreat, "],[1,"-"],[0,"40, Cute"]],"start1":469,"start2":469,"length1":16,"length2":17}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"ETREAT, "],[1,"-"],[0,"40, Cute"]],"start1":468,"start2":468,"length1":16,"length2":17}]}]},{"timestamp":1743442915335,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"ts.CM)\n\n"],[1,"def getDistance():\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS)\n\n"],[0,"def on_b"]],"start1":501,"start2":501,"length1":16,"length2":92}]}]},{"timestamp":1743469463875,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,".Cm)\n}\n\n"],[1,"function getDistance(): number {\n    return CutebotPro.ultrasonic(SonarUnit.Centimeters)\n}\n\n"],[0,"input.on"]],"start1":504,"start2":504,"length1":16,"length2":108}]}]},{"timestamp":1743469464073,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[-1,"function isWall(distanceThreshold: any) {\n    return CutebotPro.ultrasonic(SonarUnit.Centimeters) < distanceThreshold\n}\n\nfunction turnLeft() {\n    return\n}\n\nfunction turnRight() {\n    return\n}\n\nfunction moveForward() {\n    return\n}\n\nfunction navigateMaze(distanceThreshold: any, magnetThreshold: any) {\n    let move: number;\n    let moves = []\n    //  List to store past moves\n    //  Navigate maze until magnet is found\n    while (input.magneticForce(Dimension.X) < magnetThreshold) {\n        //  Maze is navigated by always followling left wall\n        //  This works by always turning left \n        turnLeft()\n        move = 1\n        while (isWall(distanceThreshold)) {\n            turnRight()\n            move += 1\n        }\n        moveForward()\n        moves.push(move)\n    }\n}\n\n"],[0,"func"]],"start1":0,"start2":0,"length1":790,"length2":4}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[-1,"def isWall(distanceThreshold):\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS) < distanceThreshold\n\ndef turnLeft():\n    return\n\ndef turnRight():\n    return\n\ndef moveForward():\n    return\n\ndef navigateMaze(distanceThreshold, magnetThreshold):\n    moves = [] # List to store past moves\n    # Navigate maze until magnet is found\n    while (input.magnetic_force(Dimension.X) < magnetThreshold):\n        # Maze is navigated by always followling left wall\n        # This works by always turning \n        turnLeft()\n        move = 1\n        while isWall(distanceThreshold):\n            turnRight()\n            move += 1\n        moveForward()\n        moves.append(move)\n\n"],[0,"def "]],"start1":0,"start2":0,"length1":675,"length2":4}]}]},{"timestamp":1743470063655,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"er;\n"],[-1,"    /** \n    The maze is navigated by always followling the left wall.\n    This works by prioritizing turning left, then going forward,\n        then turning right, and lastly backtracking.\n    The bot will turn left and then go through each direction until\n        it finds a direction it can go in.\n    Move is incremented with each turn to represent the direction the\n        bot goes, with the directions as follows:\n            1: Left turn\n            2: Forwards\n            3: Right turn\n            4: Backwards\n    These directions are stored to later be reported once the bomb is found.\n    \n */\n"],[0,"    "]],"start1":321,"start2":321,"length1":614,"length2":8},{"diffs":[[0,"//  "],[-1,"Check left direction first\n        turnLeft()\n        move = 1\n        //  Turn right until open move found"],[1,"Maze is navigated by always followling left wall\n        //  This works by always turning left \n        turnLeft()\n        move = 1"],[0,"\n   "]],"start1":494,"start2":494,"length1":115,"length2":139},{"diffs":[[0,"    "],[-1,"//  Track which direction moved\n        moveForward()\n        //  Move forward to next square"],[1,"moveForward()"],[0,"\n   "]],"start1":734,"start2":734,"length1":101,"length2":21},{"diffs":[[0,"\n}\n\n"],[-1,"//  Save move to list\n"],[0,"func"]],"start1":782,"start2":782,"length1":30,"length2":8},{"diffs":[[0,") {\n"],[-1,"    basic.showLeds(`\n    . # # # .\n    # # # # #\n    # # # # #\n    # # # # #\n    . # # # .\n    `)\n"],[0,"    "]],"start1":1359,"start2":1359,"length1":106,"length2":8},{"diffs":[[0,"use("],[-1,"10"],[1,"5"],[0,"00)\n"]],"start1":1375,"start2":1375,"length1":10,"length2":9}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"d):\n"],[-1,"    '''\n    The maze is navigated by always followling the left wall.\n    This works by prioritizing turning left, then going forward,\n        then turning right, and lastly backtracking.\n    The bot will turn left and then go through each direction until\n        it finds a direction it can go in.\n    Move is incremented with each turn to represent the direction the\n        bot goes, with the directions as follows:\n            1: Left turn\n            2: Forwards\n            3: Right turn\n            4: Backwards\n    These directions are stored to later be reported once the bomb is found.\n    '''\n"],[0,"    "]],"start1":246,"start2":246,"length1":612,"length2":8},{"diffs":[[0,"  # "],[-1,"Check left direction first"],[1,"Maze is navigated by always followling left wall\n        # This works by always turning "],[0,"\n   "]],"start1":405,"start2":405,"length1":34,"length2":96},{"diffs":[[0,"= 1\n"],[-1,"        # Turn right until open move found\n"],[0,"    "]],"start1":530,"start2":530,"length1":51,"length2":8},{"diffs":[[0,"+= 1"],[-1," # Track which direction moved\n        moveForward() # Move forward to next square"],[1,"\n        moveForward()"],[0,"\n   "]],"start1":616,"start2":616,"length1":90,"length2":30},{"diffs":[[0,"ove)"],[-1," # Save move to list"],[0,"\n\nde"]],"start1":665,"start2":665,"length1":28,"length2":8},{"diffs":[[0,"():\n"],[-1,"    basic.show_leds(\"\"\"\n    . # # # .\n    # # # # #\n    # # # # #\n    # # # # #\n    . # # # .\n    \"\"\")\n"],[0,"    "]],"start1":1203,"start2":1203,"length1":111,"length2":8},{"diffs":[[0,"use("],[-1,"10"],[1,"5"],[0,"00)\n"]],"start1":1219,"start2":1219,"length1":10,"length2":9}]}]},{"timestamp":1743470703040,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"    . # # # "],[-1,"#"],[1,"."],[0,"\n    \"\"\")\n  "]],"start1":1952,"start2":1952,"length1":25,"length2":25}]}]},{"timestamp":1743470716678,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"    "],[-1,"#"],[1,"."],[0," # # # "],[-1,"#"],[1,"."],[0,"\n    # "],[-1,". . ."],[1,"# # #"],[0," #\n "]],"start1":2068,"start2":2068,"length1":29,"length2":29},{"diffs":[[0,"# # # # #\n    # "],[-1,". . ."],[1,"# # #"],[0," #\n    # . . . #"]],"start1":2086,"start2":2086,"length1":37,"length2":37},{"diffs":[[0,"  # "],[-1,". . ."],[1,"# # #"],[0," #\n    "],[-1,"#"],[1,"."],[0," # # # "],[-1,"#"],[1,"."],[0,"\n   "]],"start1":2112,"start2":2112,"length1":29,"length2":29}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"    "],[-1,"#"],[1,"."],[0," # # # "],[-1,"#"],[1,"."],[0,"\n    # "],[-1,". . . #\n    # . . . #\n    # . . . #\n    # # # # #\n    \"\"\")\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # . . .\n        # # # # #\n  "],[1,"# # # #\n    # # # # #\n    # # # # #\n"],[0,"    "],[-1,"  "],[0,". # "],[-1,". . .\n        . . # . .\n "],[1,"# # #\n"],[0,"    "],[-1,"   "],[0,"\"\"\")\n"],[-1,"    turnLeftTest()\n"],[0,"    "]],"start1":1896,"start2":1896,"length1":251,"length2":83},{"diffs":[[0,"    "],[-1,"basic.show_leds(\"\"\"\n        . . # . .\n        . . . # .\n        # # # # #\n        . . . # .\n        . . # . .\n        \"\"\")\n    turnRightTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        \"\"\")\n    forwardTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . # . .\n        # . # . #\n        . # # # .\n        . . # . .\n        \"\"\")\n    backwardsTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        # . # . #\n        # # . # #\n        # . . . #\n        # . . . #\n        # # # # #\n        \"\"\""],[1,"turnTest()\n    moveTest("],[0,")\n\ni"]],"start1":1997,"start2":1997,"length1":634,"length2":32}]}]},{"timestamp":1743471501103,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,". #\n        # . "],[-1,"#"],[1,"."],[0," . #\n        # #"]],"start1":2744,"start2":2744,"length1":33,"length2":33}]}]},{"timestamp":1743471508765,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"unction turn"],[-1,"Left"],[0,"Test() {\n   "]],"start1":1471,"start2":1471,"length1":28,"length2":24},{"diffs":[[0,"gleUnits.Angle)\n"],[-1,"}\n\n//"],[1,"  "],[0,"  CutebotPro.tro"]],"start1":1604,"start2":1604,"length1":37,"length2":34},{"diffs":[[0,"tebotPro.trolley"],[-1,"_s"],[1,"S"],[0,"teering(CutebotP"]],"start1":1626,"start2":1626,"length1":34,"length2":33},{"diffs":[[0,"urn."],[-1,"LEFT_IN_PLACE, 90)\nfunction turnRightTest() {\n    CutebotPro.pwmCruiseControl(40, -40)\n    CutebotPro.angleRunning(CutebotProWheel.AllWheel, 330, CutebotProAngleUnits.Angle)\n}\n\n//  CutebotPro.trolley_steering(CutebotProTurn.RIGHT_IN_PLACE, 90)"],[1,"RightInPlace, 90)\n}\n"],[0,"\nfun"]],"start1":1662,"start2":1662,"length1":251,"length2":28},{"diffs":[[0,"unction move"],[-1,"Forward"],[0,"Test() {\n   "]],"start1":1688,"start2":1688,"length1":31,"length2":24},{"diffs":[[0,"Cm)\n"],[-1,"}\n\nfunction moveBackwardsTest() {\n"],[0,"    "]],"start1":1839,"start2":1839,"length1":42,"length2":8},{"diffs":[[0,"    "],[-1,"basic.showLeds(`\n        . . # . .\n        . # . . .\n        # # # # #\n        . # . . .\n        . . # . .\n        `)\n    turnLeftTest()\n    basic.pause(1000)\n    basic.showLeds(`\n        . . # . .\n        . . . # .\n        # # # # #\n        . . . # .\n        . . # . .\n        `)\n    turnRightTest()\n    basic.pause(1000)\n    basic.showLeds(`\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        `)\n    moveForwardTest()\n    basic.pause(1000)\n    basic.showLeds(`\n        . . # . .\n        . . # . .\n        # . # . #\n        . # # # .\n        . . # . .\n        `)\n    moveBackwardsTest()\n    basic.pause(1000)\n    basic.showLeds(`\n        # . # . #\n        # # . # #\n        # . . . #\n        # . . . #\n        # # # # #\n        `"],[1,"turnTest()\n    moveTest("],[0,")\n})"]],"start1":2167,"start2":2167,"length1":785,"length2":32}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"st\n\ndef turn"],[-1,"Left"],[0,"Test():\n    "]],"start1":1332,"start2":1332,"length1":28,"length2":24},{"diffs":[[0,"\n   "],[-1," # CutebotPro.trolley_steering(CutebotProTurn.LEFT_IN_PLACE, 90)\n\ndef turnRightTest():\n    CutebotPro.pwm_cruise_control(40, -40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    #"],[0," Cut"]],"start1":1483,"start2":1483,"length1":232,"length2":8},{"diffs":[[0,"0)\n\ndef move"],[-1,"Forward"],[0,"Test():\n    "]],"start1":1548,"start2":1548,"length1":31,"length2":24},{"diffs":[[0,".CM)"],[-1,"\n\ndef moveBackwardsTest():"],[0,"\n   "]],"start1":1700,"start2":1700,"length1":34,"length2":8},{"diffs":[[0,"   \"\"\")\n    "],[-1,"moveF"],[1,"f"],[0,"orwardTest()"]],"start1":2453,"start2":2453,"length1":29,"length2":25},{"diffs":[[0,"    "],[-1,"moveB"],[1,"b"],[0,"ackw"]],"start1":2628,"start2":2628,"length1":13,"length2":9},{"diffs":[[0,". #\n        # . "],[-1,"."],[1,"#"],[0," . #\n        # #"]],"start1":2744,"start2":2744,"length1":33,"length2":33}]}]},{"timestamp":1743471764344,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"  # . . . #\n"],[1,"        # . . . #\n"],[0,"        # # "]],"start1":3005,"start2":3005,"length1":24,"length2":42}]}]},{"timestamp":1743481984796,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  # . . . #\n"],[1,"        # . . . #\n"],[0,"        # # "]],"start1":3163,"start2":3163,"length1":24,"length2":42}]}]},{"timestamp":1743481984914,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"s(`\n"],[-1,"        . . . . .\n"],[0,"    "]],"start1":3117,"start2":3117,"length1":26,"length2":8}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"\"\"\"\n"],[-1,"        . . . . .\n"],[0,"    "]],"start1":2959,"start2":2959,"length1":26,"length2":8}]}]},{"timestamp":1743481991908,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0," to list"],[-1,"\n    "],[0,"\n\ndef tu"]],"start1":1326,"start2":1326,"length1":21,"length2":16}]}]},{"timestamp":1743544295248,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"    "],[-1,"\n    # E"],[0,"\n\nde"]],"start1":1335,"start2":1335,"length1":16,"length2":8}]}]},{"timestamp":1743544299367,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,")\n    }\n"],[-1,"    "],[1,"}\n\n"],[0,"//  Save"]],"start1":1437,"start2":1437,"length1":20,"length2":19},{"diffs":[[0,"ist\n"],[-1,"    /** The move list is optimized by removing moves that lead towards dead ends */\n}\n\n//  Exit maze\n"],[0,"func"]],"start1":1466,"start2":1466,"length1":109,"length2":8}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"    "],[-1,"'''\n    The move list is optimized by removing moves that lead towards dead ends\n    '''\n\n\n    # Exit maze\n"],[1,"\n    # E"],[0,"\n\nde"]],"start1":1335,"start2":1335,"length1":115,"length2":16}]}]},{"timestamp":1743544352869,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"nds\n"],[-1,"    Dead ends \n"],[0,"    "]],"start1":1416,"start2":1416,"length1":23,"length2":8}]}]},{"timestamp":1743546414895,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ist\n    /** "],[-1,"\n    "],[0,"The move lis"]],"start1":1467,"start2":1467,"length1":29,"length2":24},{"diffs":[[0,"ends"],[-1,"\n    Dead ends \n    \n"],[0," */\n"]],"start1":1547,"start2":1547,"length1":29,"length2":8}]}]},{"timestamp":1743546414977,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ead ends"],[-1,"."],[0,"\n    Dea"]],"start1":1548,"start2":1548,"length1":17,"length2":16},{"diffs":[[0,"nds "],[-1,"require the bot to turn around, represented by a 4 in the move list.\n    Duplicated moves leading up to these dead ends will add up to 4 as well.\n    The resultant move instead of turning towards the last end will be the sum\n        of the moves entering and exiting the dead end section."],[0,"\n   "]],"start1":1567,"start2":1567,"length1":296,"length2":8}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"ead ends"],[-1,"."],[0,"\n    Dea"]],"start1":1411,"start2":1411,"length1":17,"length2":16},{"diffs":[[0,"nds "],[-1,"require the bot to turn around, represented by a 4 in the move list.\n    Duplicated moves leading up to these dead ends will add up to 4 as well.\n    The resultant move instead of turning towards the last end will be the sum\n        of the moves entering and exiting the dead end section."],[0,"\n   "]],"start1":1430,"start2":1430,"length1":296,"length2":8}]}]},{"timestamp":1743546687873,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"'''\n"],[-1,"    \n"],[0,"\n\n  "]],"start1":1728,"start2":1728,"length1":13,"length2":8}]}]},{"timestamp":1743554204715,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"'''\n    "],[-1,"optimize"],[0,"\n\n\n    #"]],"start1":1728,"start2":1728,"length1":24,"length2":16}]}]},{"timestamp":1743554207671,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"ist\n"],[-1,"    //  Get an optimized list of moves to reach the bomb\n    let optimizedMoves = optimizeMoveList(moves)\n}\n\n//  Exit maze\nfunction optimizeMoveList(moves: any) {\n"],[0,"    "]],"start1":1467,"start2":1467,"length1":171,"length2":8},{"diffs":[[0," */\n"],[-1,"    let optimizedMoves = moves\n    return optimizedMoves\n}\n"],[1,"}\n\n//  Exit maze"],[0,"\nfun"]],"start1":1866,"start2":1866,"length1":67,"length2":24}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"ist\n"],[-1,"    \n    # Get an optimized list of moves to reach the bomb\n    optimizedMoves = optimizeMoveList(moves)\n\n\n    # Exit maze\n\ndef optimizeMoveList(moves):\n"],[0,"    "]],"start1":1331,"start2":1331,"length1":161,"length2":8},{"diffs":[[0,"    "],[-1,"for i in range(len(moves)):\n        if moves[i] == 4:\n            j = 1\n            while i - j >= 0 and i + j < len(moves) and moves[i - j] + moves[i + j] == 4:\n                "],[1,"optimize\n\n\n    # Exit maze"],[0,"\n\n\nd"]],"start1":1732,"start2":1732,"length1":186,"length2":34}]}]},{"timestamp":1743554804295,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0," any"],[-1,"[]"],[0,") {\n"],[-1,"    let j: number;\n"],[0,"    "]],"start1":1626,"start2":1626,"length1":33,"length2":12},{"diffs":[[0,"    "],[-1,"for (let i = 0; i < moves.length; i++) {\n        if (moves[i] == 4) {\n            j = 1\n            while (i - j >= 0 && i + j < moves.length && moves[i - j] + moves[i + j] == 4) {\n                j += 1\n            }\n            moves = []\n        }\n        \n    }"],[1,"let optimizedMoves = moves\n    return optimizedMoves"],[0,"\n}\n\n"]],"start1":2033,"start2":2033,"length1":273,"length2":60}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"    "],[-1,"j += 1\n            moves = moves[:i - j - 1] + [moves[i - j] + moves[i + j]] + moves[i + j + 1:]\n\ndef test():\n    a = []\n    a.append(1)\n    a += [2]\n    a += [3, 4]\n    "],[1,"\n"],[0,"\n\nde"]],"start1":2063,"start2":2063,"length1":178,"length2":9},{"diffs":[[0,"_a)\n"],[-1,"input.on_button_pressed(Button.B, test)\n"]],"start1":3852,"start2":3852,"length1":44,"length2":4}]}]},{"timestamp":1743555399618,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,")\n    }\n"],[-1,"}\n\n"],[1,"    "],[0,"//  Save"]],"start1":1437,"start2":1437,"length1":19,"length2":20},{"diffs":[[0,"to list\n"],[1,"    "],[0,"//  Get "]],"start1":1463,"start2":1463,"length1":16,"length2":20},{"diffs":[[0,"he bomb\n"],[-1,"// "],[1,"    let"],[0," optimiz"]],"start1":1520,"start2":1520,"length1":19,"length2":23},{"diffs":[[0,"(moves)\n"],[1,"}\n\n"],[0,"//  Exit"]],"start1":1569,"start2":1569,"length1":16,"length2":19},{"diffs":[[0,"aze\n"],[-1,"//  def"],[1,"function"],[0," opt"]],"start1":1590,"start2":1590,"length1":15,"length2":16},{"diffs":[[0,"oves"],[-1,"):\n//      '''\n//  "],[1,": any[]) {\n    let j: number;\n    /** \n"],[0,"    "]],"start1":1621,"start2":1621,"length1":27,"length2":47},{"diffs":[[0,"d ends.\n"],[-1,"//  "],[0,"    Dead"]],"start1":1734,"start2":1734,"length1":20,"length2":16},{"diffs":[[0,"e list.\n"],[-1,"//"],[0,"    "],[-1,"  "],[0,"Duplicat"]],"start1":1817,"start2":1817,"length1":24,"length2":20},{"diffs":[[0,"s well.\n"],[-1,"//  "],[0,"    The "]],"start1":1894,"start2":1894,"length1":20,"length2":16},{"diffs":[[0,"the sum\n"],[-1,"//  "],[0,"        "]],"start1":1973,"start2":1973,"length1":20,"length2":16},{"diffs":[[0,"on.\n"],[-1,"// "],[0,"    "],[-1," '''\n//      for i in range(len(moves)):\n//  "],[1,"\n */\n    for (let i = 0; i < moves.length; i++) {\n"],[0,"    "]],"start1":2041,"start2":2041,"length1":60,"length2":62},{"diffs":[[0,"     if "],[1,"("],[0,"moves[i]"]],"start1":2102,"start2":2102,"length1":16,"length2":17},{"diffs":[[0,"oves[i] == 4"],[-1,":\n//  "],[1,") {\n"],[0,"            "]],"start1":2112,"start2":2112,"length1":30,"length2":28},{"diffs":[[0,"      j = 1\n"],[-1,"//"],[0,"            "]],"start1":2134,"start2":2134,"length1":26,"length2":24},{"diffs":[[0,"            "],[-1,"  "],[0,"while (i - j"]],"start1":2146,"start2":2146,"length1":26,"length2":24},{"diffs":[[0," - j"],[-1,")"],[0," >= 0 "],[-1,"and ("],[1,"&& "],[0,"i + j"],[-1,")"],[0," < "],[-1,"len("],[0,"moves"],[-1,") and ("],[1,".length && "],[0,"move"]],"start1":2166,"start2":2166,"length1":45,"length2":41},{"diffs":[[0,"+ j]"],[-1,")"],[0," == 4"],[-1,":\n//  "],[1,") {\n"],[0,"    "]],"start1":2226,"start2":2226,"length1":20,"length2":17},{"diffs":[[0," j += 1\n"],[-1,"//"],[0,"        "]],"start1":2254,"start2":2254,"length1":18,"length2":16},{"diffs":[[0,"    "],[-1,"  newMoves = moves[:i - j - 1]\n//              newMoves.append(moves[i - j] + moves[i + j])\n//"],[1,"}\n            moves = []\n"],[0,"        "],[1,"}\n"],[0,"      "],[-1,"for k in range(i + j + 1, len(moves)):\n//                  newMoves.append(moves[k])"],[1,"  \n    }\n}\n"],[0,"\nfun"]],"start1":2270,"start2":2270,"length1":200,"length2":60},{"diffs":[[0,"\n})\n"],[-1,"input.onButtonPressed(Button.B, function test() {\n    let a = [1, 2, 3, 4, 5, 6]\n    for (let i of a) {\n        basic.showNumber(i)\n    }\n    basic.clearScreen()\n})\n"]],"start1":4078,"start2":4078,"length1":169,"length2":4}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"ile "],[-1,"("],[0,"i - j"],[-1,")"],[0," >= "]],"start1":1975,"start2":1975,"length1":15,"length2":13},{"diffs":[[0,"and "],[-1,"("],[0,"i + j"],[-1,")"],[0," < l"]],"start1":1990,"start2":1990,"length1":15,"length2":13},{"diffs":[[0,"es) and "],[-1,"("],[0,"moves[i "]],"start1":2009,"start2":2009,"length1":17,"length2":16},{"diffs":[[0,"s[i + j]"],[-1,")"],[0," == 4:\n "]],"start1":2036,"start2":2036,"length1":17,"length2":16},{"diffs":[[0,"            "],[-1,"newM"],[1,"m"],[0,"oves = moves"]],"start1":2074,"start2":2074,"length1":28,"length2":25},{"diffs":[[0,"- 1]"],[-1,"\n            newMoves.append(moves[i - j] + moves[i + j])\n            for k in range(i + j + 1, len(moves)):\n                newMoves.append(moves[k])\n\ndef test():"],[1," + [moves[i - j] + moves[i + j]] + moves[i + j + 1:]\n\ndef test():\n    a = []\n    a.append(1)"],[0,"\n    a "],[1,"+"],[0,"= ["],[-1,"1,2,3,4,5,6]\n    for i in a:\n        basic.show_number(i)\n    basic.clear_screen()"],[1,"2]\n    a += [3, 4]\n    "],[0,"\n\nde"]],"start1":2107,"start2":2107,"length1":263,"length2":134}]}]},{"timestamp":1743555993497,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"er;\n"],[-1,"    let j: number;\n    let newMoves: any[];\n"],[0,"    "]],"start1":321,"start2":321,"length1":52,"length2":8},{"diffs":[[0,"move)\n    }\n"],[-1,"    "],[1,"}\n\n"],[0,"//  Save mov"]],"start1":1433,"start2":1433,"length1":28,"length2":27},{"diffs":[[0,"to list\n"],[-1,"    "],[0,"//  Get "]],"start1":1462,"start2":1462,"length1":20,"length2":16},{"diffs":[[0,"he bomb\n"],[-1,"    /** \n"],[1,"//  optimizedMoves = optimizeMoveList(moves)\n//  Exit maze\n//  def optimizeMoveList(moves):\n//      '''\n//  "],[0,"    The "]],"start1":1515,"start2":1515,"length1":25,"length2":124},{"diffs":[[0,"d ends.\n"],[1,"//  "],[0,"    Dead"]],"start1":1701,"start2":1701,"length1":16,"length2":20},{"diffs":[[0,"e list.\n"],[1,"// "],[0,"    "],[1," "],[0,"Duplicat"]],"start1":1788,"start2":1788,"length1":20,"length2":24},{"diffs":[[0," 4 as well.\n"],[1,"//  "],[0,"    The resu"]],"start1":1865,"start2":1865,"length1":24,"length2":28},{"diffs":[[0,"the sum\n"],[1,"//  "],[0,"        "]],"start1":1952,"start2":1952,"length1":16,"length2":20},{"diffs":[[0,"on.\n"],[1,"//"],[0,"    "],[-1,"\n */\n    for (let i = 0; i < moves.length; i++) {\n"],[1,"  '''\n//      for i in range(len(moves)):\n//  "],[0,"    "]],"start1":2024,"start2":2024,"length1":62,"length2":60},{"diffs":[[0,"\n//          if "],[-1,"("],[0,"moves[i] == 4) {"]],"start1":2075,"start2":2075,"length1":33,"length2":32},{"diffs":[[0,"if moves[i] == 4"],[-1,") {\n"],[1,":\n//"],[0,"            j = "]],"start1":2088,"start2":2088,"length1":36,"length2":36},{"diffs":[[0,":\n//            "],[1,"  "],[0,"j = 1\n"],[1,"//  "],[0,"            whil"]],"start1":2104,"start2":2104,"length1":38,"length2":44},{"diffs":[[0," - j"],[1,")"],[0," >= 0 "],[-1,"&& "],[1,"and ("],[0,"i + j"],[1,")"],[0," < "],[1,"len("],[0,"moves"],[-1,".length && "],[1,") and ("],[0,"move"]],"start1":2152,"start2":2152,"length1":41,"length2":45},{"diffs":[[0,"moves[i + j]"],[1,")"],[0," == 4"],[-1,") {\n"],[1,":\n//  "],[0,"            "]],"start1":2208,"start2":2208,"length1":33,"length2":36},{"diffs":[[0,"     j += 1\n"],[-1,"    "],[1,"//"],[0,"  "],[-1,"      }\n"],[0,"            "]],"start1":2243,"start2":2243,"length1":38,"length2":28},{"diffs":[[0,"oves = moves"],[-1,".slice(0, "],[1,"[:"],[0,"i - j - 1)\n "]],"start1":2275,"start2":2275,"length1":34,"length2":26},{"diffs":[[0,"moves[:i - j - 1"],[-1,")\n"],[1,"]\n//  "],[0,"            newM"]],"start1":2282,"start2":2282,"length1":34,"length2":38},{"diffs":[[0,"       newMoves."],[-1,"push"],[1,"append"],[0,"(moves[i - j] + "]],"start1":2309,"start2":2309,"length1":36,"length2":38},{"diffs":[[0,"+ moves[i + j])\n"],[1,"//  "],[0,"            for "]],"start1":2345,"start2":2345,"length1":32,"length2":36},{"diffs":[[0,"for "],[-1,"(let k = i + j + 1; k < moves.length; k++) {\n"],[1,"k in range(i + j + 1, len(moves)):\n//  "],[0,"    "]],"start1":2377,"start2":2377,"length1":53,"length2":47},{"diffs":[[0,"       newMoves."],[-1,"push"],[1,"append"],[0,"(moves[k])\n     "]],"start1":2429,"start2":2429,"length1":36,"length2":38},{"diffs":[[0,"k])\n"],[-1,"            }\n        }\n        \n    }\n}\n\n//  Exit maze\n"],[0,"func"]],"start1":2458,"start2":2458,"length1":64,"length2":8},{"diffs":[[0,"let "],[-1,"j: number;\n    let newMoves: number[];\n    let moves = [3, 2, 1, 1, 2, 3, 2, 3, 3, 4, 1, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 4, 1, 1, 3, 2, 4, 2, 1, 1, 2, 3, 4, 1, 1, 2, 1]\n    let i = 0\n    while (i < moves.length) {\n        if (moves[i] == 4) {\n            j = 1\n            while (i - j >= 0 && i + j < moves.length && moves[i - j] + moves[i + j] == 4) {\n                j += 1\n            }\n            newMoves = moves.slice(0, i - j - 1)\n            newMoves.push(moves[i - j] + moves[i + j])\n            for (let k = i + j + 1; k < moves.length; k++) {\n                newMoves.push(moves[k])\n            }\n            moves = newMoves\n            i = 0\n        }\n        \n        i += 1\n    }\n    for (i = 0; i < moves.length; i++) {\n        basic.showNumber(moves[i])\n    }\n    //  3 2 2 1 2 3 3 2 1"],[1,"a = [1, 2, 3, 4, 5, 6]\n    for (let i of a) {\n        basic.showNumber(i)\n    }"],[0,"\n   "]],"start1":4271,"start2":4271,"length1":810,"length2":87}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"he bomb\n"],[1,"    optimizedMoves = optimizeMoveList(moves)\n\n\n    # Exit maze\n\ndef optimizeMoveList(moves):\n"],[0,"    '''\n"]],"start1":1387,"start2":1387,"length1":16,"length2":109},{"diffs":[[0,"])\n\n"],[-1,"    # Exit maze\n\n\ndef test():\n    moves = [3, 2, 1, 1, "],[1,"def test():\n    a = [1,"],[0,"2,"],[-1," "],[0,"3,"],[-1," 2, 3, 3, 4, 1, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 4, 1, 1, 3, 2, 4, 2, 1, 1, 2, 3, 4, 1, 1, 2, 1]\n    i = 0\n    while i < len(moves):\n        if moves[i] == 4:\n            j = 1\n            while (i - j) >= 0 and (i + j) < len(moves) and (moves[i - j] + moves[i + j]) == 4:\n                j += 1\n            newMoves = moves[:i - j - 1]\n            newMoves.append(moves[i - j] + moves[i + j])\n            for k in range(i + j + 1, len(moves)):\n                newMoves.append(moves[k])\n            moves = newMoves\n            i = 0\n        i += 1\n    for i in range(len(moves)):\n        basic.show_number(moves[i]) # 3 2 2 1 2 3 3 2 1"],[1,"4,5,6]\n    for i in a:\n        basic.show_number(i)"],[0,"\n   "]],"start1":2268,"start2":2268,"length1":701,"length2":86}]}]},{"timestamp":1743556557732,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"s[:i - j"],[1," - 1"],[0,"]\n      "]],"start1":2559,"start2":2559,"length1":16,"length2":20}]}]},{"timestamp":1743557403697,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"0, i - j"],[1," - 1"],[0,")\n      "]],"start1":4691,"start2":4691,"length1":16,"length2":20}]}]},{"timestamp":1743557403826,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"** \n"],[-1,"    Navigating the maze is broken into four steps as follows:\n        1: Pathfinding through the maze until the bomb is found\n        2: Calculating an optimized path to the bomb\n        3: Reversing this path to optimize exiting\n        4: Exiting the maze\n    \n    Step 1 - Pathfinding Through the Maze:\n"],[0,"    "]],"start1":374,"start2":374,"length1":314,"length2":8},{"diffs":[[0,"//  "],[-1,"Increment to t"],[1,"T"],[0,"rack"]],"start1":1364,"start2":1364,"length1":22,"length2":9},{"diffs":[[0,"rection "],[-1,"is "],[0,"moved\n  "]],"start1":1382,"start2":1382,"length1":19,"length2":16},{"diffs":[[0,"/  Save "],[-1,"direction "],[0,"move"],[-1,"d"],[0," to list"]],"start1":1494,"start2":1494,"length1":31,"length2":20},{"diffs":[[0,"   /"],[-1,"** \n    Step 2 - Calculating Optimized Path:"],[1,"/  Get an optimized list of moves to reach the bomb\n    /** "],[0,"\n   "]],"start1":1516,"start2":1516,"length1":52,"length2":68},{"diffs":[[0,"   \n */\n    "],[1,"for ("],[0,"let i = 0\n  "]],"start1":1963,"start2":1963,"length1":24,"length2":29},{"diffs":[[0," = 0"],[-1,"\n    //  Loop through the list of moves\n    while ("],[1,"; "],[0,"i < "]],"start1":1985,"start2":1985,"length1":59,"length2":10},{"diffs":[[0,"s.length"],[1,"; i++"],[0,") {\n    "]],"start1":1999,"start2":1999,"length1":16,"length2":21},{"diffs":[[0,"    "],[-1,"//  If the bot turned around on a certain move (reached a dead end)\n            j = 1\n            //  Use a second loop to find extent of dead end path"],[1,"j = 1"],[0,"\n   "]],"start1":2053,"start2":2053,"length1":159,"length2":13},{"diffs":[[0,"0, i - j"],[1," - 1"],[0,")\n      "]],"start1":2228,"start2":2228,"length1":16,"length2":20},{"diffs":[[0,"    "],[-1,"    moves = newMoves\n            i = 0\n        }\n        \n        i += 1\n    }\n    /** Step 3 - Reversing Optimized Path */\n    /** Step 4 - Exiting the Maze */"],[1,"}\n        \n    }"],[0,"\n}\n\n"]],"start1":2416,"start2":2416,"length1":168,"length2":24},{"diffs":[[0,"  `)\n})\n"],[1,"input.onButtonPressed(Button.B, function test() {\n    let j: number;\n    let newMoves: number[];\n    let moves = [3, 2, 1, 1, 2, 3, 2, 3, 3, 4, 1, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 4, 1, 1, 3, 2, 4, 2, 1, 1, 2, 3, 4, 1, 1, 2, 1]\n    let i = 0\n    while (i < moves.length) {\n        if (moves[i] == 4) {\n            j = 1\n            while (i - j >= 0 && i + j < moves.length && moves[i - j] + moves[i + j] == 4) {\n                j += 1\n            }\n            newMoves = moves.slice(0, i - j)\n            newMoves.push(moves[i - j] + moves[i + j])\n            for (let k = i + j + 1; k < moves.length; k++) {\n                newMoves.push(moves[k])\n            }\n            moves = newMoves\n            i = 0\n        }\n        \n        i += 1\n    }\n    for (i = 0; i < moves.length; i++) {\n        basic.showNumber(moves[i])\n    }\n    //  3 2 2 1 2 3 3 2 1\n    basic.clearScreen()\n})\n"]],"start1":4201,"start2":4201,"length1":8,"length2":892}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"'''\n"],[-1,"    Navigating the maze is broken into four steps as follows:\n        1: Pathfinding through the maze until the bomb is found\n        2: Calculating an optimized path to the bomb\n        3: Reversing this path to optimize exiting\n        4: Exiting the maze\n    \n    Step 1 - Pathfinding Through the Maze:\n"],[0,"    "]],"start1":254,"start2":254,"length1":314,"length2":8},{"diffs":[[0,"1 # "],[-1,"Increment to t"],[1,"T"],[0,"rack"]],"start1":1204,"start2":1204,"length1":22,"length2":9},{"diffs":[[0,"rection "],[-1,"is "],[0,"moved\n  "]],"start1":1222,"start2":1222,"length1":19,"length2":16},{"diffs":[[0," # Save "],[-1,"direction "],[0,"move"],[-1,"d"],[0," to list"]],"start1":1314,"start2":1314,"length1":31,"length2":20},{"diffs":[[0,"    "],[-1,"'''\n    Step 2 - Calculating Optimized Path:"],[1,"# Get an optimized list of moves to reach the bomb\n    '''"],[0,"\n   "]],"start1":1340,"start2":1340,"length1":52,"length2":66},{"diffs":[[0,"    "],[-1,"i = 0 # Loop through the list of moves\n"],[1,"for i in range(len(moves)):\n        if moves[i] == 4:\n            j = 1\n        "],[0,"    "]],"start1":1792,"start2":1792,"length1":47,"length2":88},{"diffs":[[0,"ile "],[1,"("],[0,"i "],[-1,"< len(moves):\n        if moves[i] == 4: # If the bot turned around on a certain move (reached a dead end)\n            j = 1 # Use a second loop to find extent of dead end path"],[1,"- j) >= 0 and (i + j) < len(moves) and (moves[i - j] + moves[i + j]) == 4:\n                j += 1\n            newMoves = moves[:i - j - 1]\n            newMoves.append(moves[i - j] + moves[i + j])\n            for k in range(i + j + 1, len(moves)):\n                newMoves.append(moves[k])\n\n    # Exit maze\n\n\ndef test():\n    moves = [3, 2, 1, 1, 2, 3, 2, 3, 3, 4, 1, 1, 2, 1, 2, 3, 1, 1, 2, 1, 3, 4, 1, 1, 3, 2, 4, 2, 1, 1, 2, 3, 4, 1, 1, 2, 1]\n    i = 0\n    while i < len(moves):\n        if moves[i] == 4:\n            j = 1"],[0,"\n   "]],"start1":1882,"start2":1882,"length1":185,"length2":534},{"diffs":[[0,"    "],[-1,"'''\n    Step 3 - Reversing Optimized Path \n    '''\n\n    '''\n    Step 4 - Exiting the Maze\n    '''\n    # Exit maze\n"],[1,"for i in range(len(moves)):\n        basic.show_number(moves[i]) # 3 2 2 1 2 3 3 2 1\n    basic.clear_screen()"],[0,"\n\nde"]],"start1":2781,"start2":2781,"length1":122,"length2":116},{"diffs":[[0,"ssed_a)\n"],[1,"input.on_button_pressed(Button.B, test)\n"]],"start1":4673,"start2":4673,"length1":8,"length2":48}]}]},{"timestamp":1743557826840,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"  }\n    /** "],[-1,"\n    "],[0,"Step 3 - Rev"]],"start1":2993,"start2":2993,"length1":29,"length2":24},{"diffs":[[0,"Path"],[-1,"\n    Reversing the optimized path can be done by first reversing the order of\n        the optimized path from the previous step and then subtracting each\n        element from 4 to find the opposite of each of the steps taken.\n    \n"],[0," */\n"]],"start1":3034,"start2":3034,"length1":239,"length2":8}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0," i += 1\n"],[-1,"\n"],[0,"    '''\n"]],"start1":2702,"start2":2702,"length1":17,"length2":16},{"diffs":[[0,"Path"],[-1,"\n    Reversing the optimized path can be done by first reversing the order of\n        the optimized path from the previous step and then subtracting each\n        element from 4 to find the opposite of each of the steps taken."],[1," "],[0,"\n   "]],"start1":2751,"start2":2751,"length1":233,"length2":9}]}]},{"timestamp":1743558356899,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"\n    '''"],[-1,"\n    "],[0,"\n\n    ''"]],"start1":2981,"start2":2981,"length1":21,"length2":16}]}]},{"timestamp":1743559380532,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"    "],[-1,"exitMoves = "],[0,"\n\n  "]],"start1":2990,"start2":2990,"length1":20,"length2":8}]}]},{"timestamp":1743559384116,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"wMoves: "],[-1,"number"],[1,"any"],[0,"[];\n    "]],"start1":354,"start2":354,"length1":22,"length2":19},{"diffs":[[0,"    "],[-1,"let exitMoves = []\n    for (i = 0; i < moves.length; i++) {\n        exitMoves.push(4 - moves[moves.length - i - 1])\n    }\n    /** \n    Step 4 - Exiting the Maze\n    The bot can exit the maze by turning around, moving forwards, then\n        simply following the list of exit moves.\n    \n */\n    //  Exit maze\n    turnRight()\n    turnRight()\n    moveForward()\n}\n"],[1,"/** Step 4 - Exiting the Maze */\n}\n\n//  Exit maze"],[0,"\nfun"]],"start1":3278,"start2":3278,"length1":368,"length2":57}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"+= 1"],[-1," # Increment j to move on to next pair of values\n            # Build new list of moves with dead ends filtered out"],[0,"\n   "]],"start1":2456,"start2":2456,"length1":122,"length2":8},{"diffs":[[0,"- j]"],[-1," # Moves before dead end"],[0,"\n   "]],"start1":2493,"start2":2493,"length1":32,"length2":8},{"diffs":[[0," j])"],[-1," # Move made of combined moves entering and leaving dead end"],[0,"\n   "]],"start1":2550,"start2":2550,"length1":68,"length2":8},{"diffs":[[0,"s)):"],[-1," # Moves after dead end"],[0,"\n   "]],"start1":2601,"start2":2601,"length1":31,"length2":8},{"diffs":[[0," = 0"],[-1," # Length and index of list changes. I could calculate the new list but its easier to just start at the beginning again.\n        i += 1 # Increment i to move on to next index"],[1,"\n        i += 1"],[0,"\n\n  "]],"start1":2690,"start2":2690,"length1":182,"length2":23},{"diffs":[[0,"s = "],[-1,"[]\n    for i in range(len(moves)):\n        exitMoves.append(4 - moves[len(moves) - i - 1])\n\n    '''\n    Step 4 - Exiting the Maze\n    The bot can exit the maze by turning around, moving forwards, then\n        simply following the list of exit moves.\n    '''\n    # Exit maze\n    turnRight()\n    turnRight()\n    moveForward()\n    for i in range(len(exitMoves)):\n"],[1,"\n\n    '''\n    Step 4 - Exiting the Maze\n    '''\n    # Exit maze"],[0,"\n\n\nd"]],"start1":3002,"start2":3002,"length1":368,"length2":71}]}]},{"timestamp":1743559862207,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0," of "],[-1,"_py.Dict."],[0,"values"],[-1,"()"],[0,"\n   "]],"start1":2498,"start2":2498,"length1":25,"length2":14}]}]},{"timestamp":1743560219692,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"pair of "],[1,"_py.Dict.values()"],[0,"\n       "]],"start1":2494,"start2":2494,"length1":16,"length2":33}]}]},{"timestamp":1743560848873,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.py","patch":[{"diffs":[[0," of "],[-1,"values"],[0,"\n   "]],"start1":2498,"start2":2498,"length1":14,"length2":8}]}]},{"timestamp":1743560851120,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"er;\n"],[-1,"    let i: number;\n"],[0,"    "]],"start1":321,"start2":321,"length1":27,"length2":8},{"diffs":[[0,"   \n */\n    "],[1,"let "],[0,"i = 0\n    //"]],"start1":2283,"start2":2283,"length1":24,"length2":28},{"diffs":[[0,"  }\n"],[-1,"            //  Increment j to move on to next pair of values\n            //  Build new list of moves with dead ends filtered out\n"],[0,"    "]],"start1":2694,"start2":2694,"length1":138,"length2":8},{"diffs":[[0," j)\n"],[-1,"            //  Moves before dead end\n"],[0,"    "]],"start1":2739,"start2":2739,"length1":46,"length2":8},{"diffs":[[0,"j])\n"],[-1,"            //  Move made of combined moves entering and leaving dead end\n"],[0,"    "]],"start1":2794,"start2":2794,"length1":82,"length2":8},{"diffs":[[0,") {\n"],[-1,"                //  Moves after dead end\n"],[0,"    "]],"start1":2855,"start2":2855,"length1":49,"length2":8},{"diffs":[[0,"    "],[-1,"//  Length and index of list changes. I could calculate the new list but its easier to just start at the beginning again.\n        i += 1\n    }\n    //  Increment i to move on to next index"],[1,"i += 1\n    }"],[0,"\n   "]],"start1":2983,"start2":2983,"length1":195,"length2":20},{"diffs":[[0,"d()\n"],[-1,"    for (i = 0; i < exitMoves.length; i++) {\n        if (i == 1) {\n            turnLeft()\n        } else if (i == 2) {\n            moveForward()\n        } else {\n            turnRight()\n        }\n        \n    }\n    moveForward()\n"],[0,"}\n\nf"]],"start1":3639,"start2":3639,"length1":237,"length2":8}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,")):\n"],[-1,"        if i == 1:\n            turnLeft()\n        elif i == 2:\n            moveForward()\n        else:\n            turnRight()\n    moveForward()"],[0,"\n\n\nd"]],"start1":3742,"start2":3742,"length1":152,"length2":8}]}]},{"timestamp":1743561296402,"editorVersion":"7.0.57","changes":[{"type":"edited","filename":"main.blocks","patch":[{"diffs":[[0,"ion\""],[-1," id=\"k(Y{rFteYlKahe@[_4]x\""],[0," x=\""]],"start1":107,"start2":107,"length1":34,"length2":8},{"diffs":[[0,"rol\""],[-1," id=\"B_jzmw`-F2IL5~kxEDfP\""],[0,"><va"]],"start1":304,"start2":304,"length1":34,"length2":8},{"diffs":[[0,"ber\""],[-1," id=\"2%MJZ(^sw0I,iNV)%HrK\""],[0,"><fi"]],"start1":352,"start2":352,"length1":34,"length2":8},{"diffs":[[0,"ber\""],[-1," id=\"S4WIVr3x-j8zrA_XfV;H\""],[0,"><fi"]],"start1":446,"start2":446,"length1":34,"length2":8},{"diffs":[[0,"ing\""],[-1," id=\"ku$*fcZ)t|4g23X/4d2V\""],[0,"><fi"]],"start1":535,"start2":535,"length1":34,"length2":8},{"diffs":[[0,"ber\""],[-1," id=\"d.{R4Z;wWzA{4r(t%ffW\""],[0,"><fi"]],"start1":713,"start2":713,"length1":34,"length2":8},{"diffs":[[0,"ing\""],[-1," id=\"Sjx{UtPN/pPf7`C[//zd\""],[0,"><fi"]],"start1":806,"start2":806,"length1":34,"length2":8},{"diffs":[[0,"max\""],[-1," id=\"ctf(HBLbo!V.)^marFEt\""],[0,"><mu"]],"start1":923,"start2":923,"length1":34,"length2":8},{"diffs":[[0,"ion\""],[-1," id=\"z~j-UV}E=~)wD9:GvYos\""],[0," x=\""]],"start1":1130,"start2":1130,"length1":34,"length2":8},{"diffs":[[0,"urn\""],[-1," id=\"A|d5lxaXrAluh#12=Z)Q\""],[0,"><mu"]],"start1":1317,"start2":1317,"length1":34,"length2":8},{"diffs":[[0,"ber\""],[-1," id=\"B+D*0yV!!eY5Y^1jdni}\""],[0,"><fi"]],"start1":1453,"start2":1453,"length1":34,"length2":8},{"diffs":[[0,"nic\""],[-1," id=\"6PLj!MGH{uVewuEQg3@~\""],[0,"><fi"]],"start1":1514,"start2":1514,"length1":34,"length2":8},{"diffs":[[0,"ent\""],[-1," id=\"8eFdzvz*Wfe%~bbFphOK\""],[0," x=\""]],"start1":1645,"start2":1645,"length1":34,"length2":8},{"diffs":[[0,"all\""],[-1," id=\"2DD5FA4ubFgO.M}NdYBB\""],[0,"><mu"]],"start1":1750,"start2":1750,"length1":34,"length2":8}]},{"type":"edited","filename":"main.ts","patch":[{"diffs":[[0,"e {\n"],[-1,"            //  Only options are 1, 2, or 3\n"],[0,"    "]],"start1":4274,"start2":4274,"length1":52,"length2":8}]},{"type":"edited","filename":"pxt.json","patch":[{"diffs":[[0," ],\n"],[-1,"    \"testFiles\": [\n        \"test.ts\"\n    ],\n"],[0,"    "]],"start1":319,"start2":319,"length1":52,"length2":8}]},{"type":"edited","filename":"main.py","patch":[{"diffs":[[0,"lse:"],[-1," # Only options are 1, 2, or 3"],[0,"\n   "]],"start1":3844,"start2":3844,"length1":38,"length2":8}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1743441148516,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"Pathfinding\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1743471474448,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"function_definition\" x=\"337\" y=\"-38\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation><field name=\"function_name\">turnLeft</field><statement name=\"STACK\"><block type=\"CutebotPro_pwmCruiseControl\"><value name=\"speedL\"><shadow type=\"math_number\"><field name=\"NUM\">-40</field></shadow></value><value name=\"speedR\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">330</field></shadow></value><next><block type=\"CutebotPro_trolleySteering\"><field name=\"CutebotProTurn\">CutebotProTurn.LeftInPlace</field><value name=\"angle\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"360\" label=\"Angle\" precision=\"0\"></mutation><field name=\"SLIDER\">90</field></shadow></value></block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"0\" y=\"0\"><mutation name=\"getDistance\" functionid=\"GK`mzhe7zP4|3%r4.EHQ\"></mutation><field name=\"function_name\">getDistance</field><statement name=\"STACK\"><block type=\"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation><value name=\"RETURN_VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters</field></block></value></block></statement></block><block type=\"device_button_event\" x=\"-36\" y=\"164\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","main.py":"def isWall(distanceThreshold):\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS) < distanceThreshold\n\ndef turnLeft():\n    return\n\ndef turnRight():\n    return\n\ndef moveForward():\n    return\n\ndef navigateMaze(distanceThreshold, magnetThreshold):\n    '''\n    The maze is navigated by always followling the left wall.\n    This works by prioritizing turning left, then going forward,\n        then turning right, and lastly backtracking.\n    The bot will turn left and then go through each direction until\n        it finds a direction it can go in.\n    Move is incremented with each turn to represent the direction the\n        bot goes, with the directions as follows:\n            1: Left turn\n            2: Forwards\n            3: Right turn\n            4: Backwards\n    These directions are stored to later be reported once the bomb is found.\n    '''\n    moves = [] # List to store past moves\n    # Navigate maze until magnet is found\n    while (input.magnetic_force(Dimension.X) < magnetThreshold):\n        # Check left direction first\n        turnLeft()\n        move = 1\n        # Turn right until open move found\n        while isWall(distanceThreshold):\n            turnRight()\n            move += 1 # Track which direction moved\n        moveForward() # Move forward to next square\n        moves.append(move) # Save move to list\n\ndef turnTest():\n    CutebotPro.pwm_cruise_control(-40, 40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    CutebotPro.trolley_steering(CutebotProTurn.RIGHT_IN_PLACE, 90)\n\ndef moveTest():\n    CutebotPro.pwm_cruise_control(40, 40)\n    CutebotPro.distance_running(CutebotProOrientation.ADVANCE, 40, CutebotProDistanceUnits.CM)\n    CutebotPro.pwm_cruise_control(-20, -20)\n    CutebotPro.distance_running(CutebotProOrientation.RETREAT, 40, CutebotProDistanceUnits.CM)\n\ndef on_button_pressed_a():\n    basic.show_leds(\"\"\"\n    # # # # #\n    # . . . #\n    # . . . #\n    # . . . #\n    # # # # #\n    \"\"\")\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # . . .\n        # # # # #\n        . # . . .\n        . . # . .\n        \"\"\")\n    turnLeftTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . . # .\n        # # # # #\n        . . . # .\n        . . # . .\n        \"\"\")\n    turnRightTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        \"\"\")\n    forwardTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . # . .\n        # . # . #\n        . # # # .\n        . . # . .\n        \"\"\")\n    backwardsTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        # . # . #\n        # # . # #\n        # . . . #\n        # . . . #\n        # # # # #\n        \"\"\")\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n","pxt.json":"{\n    \"name\": \"Pathfinding\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-cutebotpro\": \"github:elecfreaks/pxt-cutebot-pro#v2.1.0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1743481984796,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"function_definition\" x=\"337\" y=\"-38\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation><field name=\"function_name\">turnLeft</field><statement name=\"STACK\"><block type=\"CutebotPro_pwmCruiseControl\"><value name=\"speedL\"><shadow type=\"math_number\"><field name=\"NUM\">-40</field></shadow></value><value name=\"speedR\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">330</field></shadow></value><next><block type=\"CutebotPro_trolleySteering\"><field name=\"CutebotProTurn\">CutebotProTurn.LeftInPlace</field><value name=\"angle\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"360\" label=\"Angle\" precision=\"0\"></mutation><field name=\"SLIDER\">90</field></shadow></value></block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"0\" y=\"0\"><mutation name=\"getDistance\" functionid=\"GK`mzhe7zP4|3%r4.EHQ\"></mutation><field name=\"function_name\">getDistance</field><statement name=\"STACK\"><block type=\"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation><value name=\"RETURN_VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters</field></block></value></block></statement></block><block type=\"device_button_event\" x=\"-36\" y=\"164\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","main.py":"def isWall(distanceThreshold):\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS) < distanceThreshold\n\ndef turnLeft():\n    return\n\ndef turnRight():\n    return\n\ndef moveForward():\n    return\n\ndef navigateMaze(distanceThreshold, magnetThreshold):\n    '''\n    The maze is navigated by always followling the left wall.\n    This works by prioritizing turning left, then going forward,\n        then turning right, and lastly backtracking.\n    The bot will turn left and then go through each direction until\n        it finds a direction it can go in.\n    Move is incremented with each turn to represent the direction the\n        bot goes, with the directions as follows:\n            1: Left turn\n            2: Forwards\n            3: Right turn\n            4: Backwards\n    These directions are stored to later be reported once the bomb is found.\n    '''\n    moves = [] # List to store past moves\n    # Navigate maze until magnet is found\n    while (input.magnetic_force(Dimension.X) < magnetThreshold):\n        # Check left direction first\n        turnLeft()\n        move = 1\n        # Turn right until open move found\n        while isWall(distanceThreshold):\n            turnRight()\n            move += 1 # Track which direction moved\n        moveForward() # Move forward to next square\n        moves.append(move) # Save move to list\n\ndef turnLeftTest():\n    CutebotPro.pwm_cruise_control(-40, 40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.LEFT_IN_PLACE, 90)\n\ndef turnRightTest():\n    CutebotPro.pwm_cruise_control(40, -40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.RIGHT_IN_PLACE, 90)\n\ndef moveForwardTest():\n    CutebotPro.pwm_cruise_control(40, 40)\n    CutebotPro.distance_running(CutebotProOrientation.ADVANCE, 40, CutebotProDistanceUnits.CM)\n\ndef moveBackwardsTest():\n    CutebotPro.pwm_cruise_control(-20, -20)\n    CutebotPro.distance_running(CutebotProOrientation.RETREAT, 40, CutebotProDistanceUnits.CM)\n\ndef on_button_pressed_a():\n    basic.show_leds(\"\"\"\n    # # # # #\n    # . . . #\n    # . . . #\n    # . . . #\n    # # # # #\n    \"\"\")\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # . . .\n        # # # # #\n        . # . . .\n        . . # . .\n        \"\"\")\n    turnLeftTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . . # .\n        # # # # #\n        . . . # .\n        . . # . .\n        \"\"\")\n    turnRightTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        \"\"\")\n    moveForwardTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . # . .\n        # . # . #\n        . # # # .\n        . . # . .\n        \"\"\")\n    moveBackwardsTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        # . # . #\n        # # . # #\n        # . . . #\n        # . . . #\n        # # # # #\n        \"\"\")\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n","pxt.json":"{\n    \"name\": \"Pathfinding\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-cutebotpro\": \"github:elecfreaks/pxt-cutebot-pro#v2.1.0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1743544295248,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"function_definition\" x=\"337\" y=\"-38\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation><field name=\"function_name\">turnLeft</field><statement name=\"STACK\"><block type=\"CutebotPro_pwmCruiseControl\"><value name=\"speedL\"><shadow type=\"math_number\"><field name=\"NUM\">-40</field></shadow></value><value name=\"speedR\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">330</field></shadow></value><next><block type=\"CutebotPro_trolleySteering\"><field name=\"CutebotProTurn\">CutebotProTurn.LeftInPlace</field><value name=\"angle\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"360\" label=\"Angle\" precision=\"0\"></mutation><field name=\"SLIDER\">90</field></shadow></value></block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"0\" y=\"0\"><mutation name=\"getDistance\" functionid=\"GK`mzhe7zP4|3%r4.EHQ\"></mutation><field name=\"function_name\">getDistance</field><statement name=\"STACK\"><block type=\"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation><value name=\"RETURN_VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters</field></block></value></block></statement></block><block type=\"device_button_event\" x=\"-36\" y=\"164\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","main.py":"def isWall(distanceThreshold):\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS) < distanceThreshold\n\ndef turnLeft():\n    return\n\ndef turnRight():\n    return\n\ndef moveForward():\n    return\n\ndef navigateMaze(distanceThreshold, magnetThreshold):\n    '''\n    The maze is navigated by always followling the left wall.\n    This works by prioritizing turning left, then going forward,\n        then turning right, and lastly backtracking.\n    The bot will turn left and then go through each direction until\n        it finds a direction it can go in.\n    Move is incremented with each turn to represent the direction the\n        bot goes, with the directions as follows:\n            1: Left turn\n            2: Forwards\n            3: Right turn\n            4: Backwards\n    These directions are stored to later be reported once the bomb is found.\n    '''\n    moves = [] # List to store past moves\n    # Navigate maze until magnet is found\n    while (input.magnetic_force(Dimension.X) < magnetThreshold):\n        # Check left direction first\n        turnLeft()\n        move = 1\n        # Turn right until open move found\n        while isWall(distanceThreshold):\n            turnRight()\n            move += 1 # Track which direction moved\n        moveForward() # Move forward to next square\n        moves.append(move) # Save move to list\n\ndef turnLeftTest():\n    CutebotPro.pwm_cruise_control(-40, 40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.LEFT_IN_PLACE, 90)\n\ndef turnRightTest():\n    CutebotPro.pwm_cruise_control(40, -40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.RIGHT_IN_PLACE, 90)\n\ndef moveForwardTest():\n    CutebotPro.pwm_cruise_control(40, 40)\n    CutebotPro.distance_running(CutebotProOrientation.ADVANCE, 40, CutebotProDistanceUnits.CM)\n\ndef moveBackwardsTest():\n    CutebotPro.pwm_cruise_control(-20, -20)\n    CutebotPro.distance_running(CutebotProOrientation.RETREAT, 40, CutebotProDistanceUnits.CM)\n\ndef on_button_pressed_a():\n    basic.show_leds(\"\"\"\n    # # # # #\n    # . . . #\n    # . . . #\n    # . . . #\n    # # # # #\n    \"\"\")\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # . . .\n        # # # # #\n        . # . . .\n        . . # . .\n        \"\"\")\n    turnLeftTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . . # .\n        # # # # #\n        . . . # .\n        . . # . .\n        \"\"\")\n    turnRightTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        \"\"\")\n    moveForwardTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . # . .\n        # . # . #\n        . # # # .\n        . . # . .\n        \"\"\")\n    moveBackwardsTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . . . .\n        # . # . #\n        # # . # #\n        # . . . #\n        # # # # #\n        \"\"\")\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n","pxt.json":"{\n    \"name\": \"Pathfinding\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-cutebotpro\": \"github:elecfreaks/pxt-cutebot-pro#v2.1.0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1743546414895,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"function_definition\" x=\"337\" y=\"-38\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation><field name=\"function_name\">turnLeft</field><statement name=\"STACK\"><block type=\"CutebotPro_pwmCruiseControl\"><value name=\"speedL\"><shadow type=\"math_number\"><field name=\"NUM\">-40</field></shadow></value><value name=\"speedR\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">330</field></shadow></value><next><block type=\"CutebotPro_trolleySteering\"><field name=\"CutebotProTurn\">CutebotProTurn.LeftInPlace</field><value name=\"angle\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"360\" label=\"Angle\" precision=\"0\"></mutation><field name=\"SLIDER\">90</field></shadow></value></block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"0\" y=\"0\"><mutation name=\"getDistance\" functionid=\"GK`mzhe7zP4|3%r4.EHQ\"></mutation><field name=\"function_name\">getDistance</field><statement name=\"STACK\"><block type=\"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation><value name=\"RETURN_VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters</field></block></value></block></statement></block><block type=\"device_button_event\" x=\"-36\" y=\"164\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","main.py":"def isWall(distanceThreshold):\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS) < distanceThreshold\n\ndef turnLeft():\n    return\n\ndef turnRight():\n    return\n\ndef moveForward():\n    return\n\ndef navigateMaze(distanceThreshold, magnetThreshold):\n    '''\n    The maze is navigated by always followling the left wall.\n    This works by prioritizing turning left, then going forward,\n        then turning right, and lastly backtracking.\n    The bot will turn left and then go through each direction until\n        it finds a direction it can go in.\n    Move is incremented with each turn to represent the direction the\n        bot goes, with the directions as follows:\n            1: Left turn\n            2: Forwards\n            3: Right turn\n            4: Backwards\n    These directions are stored to later be reported once the bomb is found.\n    '''\n    moves = [] # List to store past moves\n    # Navigate maze until magnet is found\n    while (input.magnetic_force(Dimension.X) < magnetThreshold):\n        # Check left direction first\n        turnLeft()\n        move = 1\n        # Turn right until open move found\n        while isWall(distanceThreshold):\n            turnRight()\n            move += 1 # Track which direction moved\n        moveForward() # Move forward to next square\n        moves.append(move) # Save move to list\n    '''\n    The move list is optimized by removing moves that lead towards dead ends\n    '''\n\n\n    # Exit maze\n\n\ndef turnLeftTest():\n    CutebotPro.pwm_cruise_control(-40, 40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.LEFT_IN_PLACE, 90)\n\ndef turnRightTest():\n    CutebotPro.pwm_cruise_control(40, -40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.RIGHT_IN_PLACE, 90)\n\ndef moveForwardTest():\n    CutebotPro.pwm_cruise_control(40, 40)\n    CutebotPro.distance_running(CutebotProOrientation.ADVANCE, 40, CutebotProDistanceUnits.CM)\n\ndef moveBackwardsTest():\n    CutebotPro.pwm_cruise_control(-20, -20)\n    CutebotPro.distance_running(CutebotProOrientation.RETREAT, 40, CutebotProDistanceUnits.CM)\n\ndef on_button_pressed_a():\n    basic.show_leds(\"\"\"\n    # # # # #\n    # . . . #\n    # . . . #\n    # . . . #\n    # # # # #\n    \"\"\")\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # . . .\n        # # # # #\n        . # . . .\n        . . # . .\n        \"\"\")\n    turnLeftTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . . # .\n        # # # # #\n        . . . # .\n        . . # . .\n        \"\"\")\n    turnRightTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        \"\"\")\n    moveForwardTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . # . .\n        # . # . #\n        . # # # .\n        . . # . .\n        \"\"\")\n    moveBackwardsTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . . . .\n        # . # . #\n        # # . # #\n        # . . . #\n        # # # # #\n        \"\"\")\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n","pxt.json":"{\n    \"name\": \"Pathfinding\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-cutebotpro\": \"github:elecfreaks/pxt-cutebot-pro#v2.1.0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1743554204715,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"function_definition\" x=\"337\" y=\"-38\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation><field name=\"function_name\">turnLeft</field><statement name=\"STACK\"><block type=\"CutebotPro_pwmCruiseControl\"><value name=\"speedL\"><shadow type=\"math_number\"><field name=\"NUM\">-40</field></shadow></value><value name=\"speedR\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">330</field></shadow></value><next><block type=\"CutebotPro_trolleySteering\"><field name=\"CutebotProTurn\">CutebotProTurn.LeftInPlace</field><value name=\"angle\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"360\" label=\"Angle\" precision=\"0\"></mutation><field name=\"SLIDER\">90</field></shadow></value></block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"0\" y=\"0\"><mutation name=\"getDistance\" functionid=\"GK`mzhe7zP4|3%r4.EHQ\"></mutation><field name=\"function_name\">getDistance</field><statement name=\"STACK\"><block type=\"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation><value name=\"RETURN_VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters</field></block></value></block></statement></block><block type=\"device_button_event\" x=\"-36\" y=\"164\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","main.py":"def isWall(distanceThreshold):\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS) < distanceThreshold\n\ndef turnLeft():\n    return\n\ndef turnRight():\n    return\n\ndef moveForward():\n    return\n\ndef navigateMaze(distanceThreshold, magnetThreshold):\n    '''\n    The maze is navigated by always followling the left wall.\n    This works by prioritizing turning left, then going forward,\n        then turning right, and lastly backtracking.\n    The bot will turn left and then go through each direction until\n        it finds a direction it can go in.\n    Move is incremented with each turn to represent the direction the\n        bot goes, with the directions as follows:\n            1: Left turn\n            2: Forwards\n            3: Right turn\n            4: Backwards\n    These directions are stored to later be reported once the bomb is found.\n    '''\n    moves = [] # List to store past moves\n    # Navigate maze until magnet is found\n    while (input.magnetic_force(Dimension.X) < magnetThreshold):\n        # Check left direction first\n        turnLeft()\n        move = 1\n        # Turn right until open move found\n        while isWall(distanceThreshold):\n            turnRight()\n            move += 1 # Track which direction moved\n        moveForward() # Move forward to next square\n        moves.append(move) # Save move to list\n    '''\n    The move list is optimized by removing moves that lead towards dead ends.\n    Dead ends require the bot to turn around, represented by a 4 in the move list.\n    Duplicated moves leading up to these dead ends will add up to 4 as well.\n    The resultant move instead of turning towards the last end will be the sum\n        of the moves entering and exiting the dead end section.\n    '''\n\n\n    # Exit maze\n\n\ndef turnLeftTest():\n    CutebotPro.pwm_cruise_control(-40, 40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.LEFT_IN_PLACE, 90)\n\ndef turnRightTest():\n    CutebotPro.pwm_cruise_control(40, -40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.RIGHT_IN_PLACE, 90)\n\ndef moveForwardTest():\n    CutebotPro.pwm_cruise_control(40, 40)\n    CutebotPro.distance_running(CutebotProOrientation.ADVANCE, 40, CutebotProDistanceUnits.CM)\n\ndef moveBackwardsTest():\n    CutebotPro.pwm_cruise_control(-20, -20)\n    CutebotPro.distance_running(CutebotProOrientation.RETREAT, 40, CutebotProDistanceUnits.CM)\n\ndef on_button_pressed_a():\n    basic.show_leds(\"\"\"\n    # # # # #\n    # . . . #\n    # . . . #\n    # . . . #\n    # # # # #\n    \"\"\")\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # . . .\n        # # # # #\n        . # . . .\n        . . # . .\n        \"\"\")\n    turnLeftTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . . # .\n        # # # # #\n        . . . # .\n        . . # . .\n        \"\"\")\n    turnRightTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        \"\"\")\n    moveForwardTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . # . .\n        # . # . #\n        . # # # .\n        . . # . .\n        \"\"\")\n    moveBackwardsTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . . . .\n        # . # . #\n        # # . # #\n        # . . . #\n        # # # # #\n        \"\"\")\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n","pxt.json":"{\n    \"name\": \"Pathfinding\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-cutebotpro\": \"github:elecfreaks/pxt-cutebot-pro#v2.1.0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1743556005928,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"function_definition\" x=\"337\" y=\"-38\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation><field name=\"function_name\">turnLeft</field><statement name=\"STACK\"><block type=\"CutebotPro_pwmCruiseControl\"><value name=\"speedL\"><shadow type=\"math_number\"><field name=\"NUM\">-40</field></shadow></value><value name=\"speedR\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">330</field></shadow></value><next><block type=\"CutebotPro_trolleySteering\"><field name=\"CutebotProTurn\">CutebotProTurn.LeftInPlace</field><value name=\"angle\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"360\" label=\"Angle\" precision=\"0\"></mutation><field name=\"SLIDER\">90</field></shadow></value></block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"0\" y=\"0\"><mutation name=\"getDistance\" functionid=\"GK`mzhe7zP4|3%r4.EHQ\"></mutation><field name=\"function_name\">getDistance</field><statement name=\"STACK\"><block type=\"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation><value name=\"RETURN_VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters</field></block></value></block></statement></block><block type=\"device_button_event\" x=\"-36\" y=\"164\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","main.py":"def isWall(distanceThreshold):\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS) < distanceThreshold\n\ndef turnLeft():\n    return\n\ndef turnRight():\n    return\n\ndef moveForward():\n    return\n\ndef navigateMaze(distanceThreshold, magnetThreshold):\n    '''\n    The maze is navigated by always followling the left wall.\n    This works by prioritizing turning left, then going forward,\n        then turning right, and lastly backtracking.\n    The bot will turn left and then go through each direction until\n        it finds a direction it can go in.\n    Move is incremented with each turn to represent the direction the\n        bot goes, with the directions as follows:\n            1: Left turn\n            2: Forwards\n            3: Right turn\n            4: Backwards\n    These directions are stored to later be reported once the bomb is found.\n    '''\n    moves = [] # List to store past moves\n    # Navigate maze until magnet is found\n    while (input.magnetic_force(Dimension.X) < magnetThreshold):\n        # Check left direction first\n        turnLeft()\n        move = 1\n        # Turn right until open move found\n        while isWall(distanceThreshold):\n            turnRight()\n            move += 1 # Track which direction moved\n        moveForward() # Move forward to next square\n        moves.append(move) # Save move to list\n    \n    # Get an optimized list of moves to reach the bomb\n    optimizedMoves = optimizeMoveList(moves)\n\n\n    # Exit maze\n\ndef optimizeMoveList(moves):\n    \n\ndef test():\n    a = [1,2,3,4,5,6]\n    for i in a:\n        basic.show_number(i)\n    basic.clear_screen()\n\ndef turnLeftTest():\n    CutebotPro.pwm_cruise_control(-40, 40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.LEFT_IN_PLACE, 90)\n\ndef turnRightTest():\n    CutebotPro.pwm_cruise_control(40, -40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.RIGHT_IN_PLACE, 90)\n\ndef moveForwardTest():\n    CutebotPro.pwm_cruise_control(40, 40)\n    CutebotPro.distance_running(CutebotProOrientation.ADVANCE, 40, CutebotProDistanceUnits.CM)\n\ndef moveBackwardsTest():\n    CutebotPro.pwm_cruise_control(-20, -20)\n    CutebotPro.distance_running(CutebotProOrientation.RETREAT, 40, CutebotProDistanceUnits.CM)\n\ndef on_button_pressed_a():\n    basic.show_leds(\"\"\"\n    # # # # #\n    # . . . #\n    # . . . #\n    # . . . #\n    # # # # #\n    \"\"\")\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # . . .\n        # # # # #\n        . # . . .\n        . . # . .\n        \"\"\")\n    turnLeftTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . . # .\n        # # # # #\n        . . . # .\n        . . # . .\n        \"\"\")\n    turnRightTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        \"\"\")\n    moveForwardTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . # . .\n        # . # . #\n        . # # # .\n        . . # . .\n        \"\"\")\n    moveBackwardsTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . . . .\n        # . # . #\n        # # . # #\n        # . . . #\n        # # # # #\n        \"\"\")\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\ninput.on_button_pressed(Button.B, test)\n","pxt.json":"{\n    \"name\": \"Pathfinding\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-cutebotpro\": \"github:elecfreaks/pxt-cutebot-pro#v2.1.0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1743557806818,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"function_definition\" x=\"337\" y=\"-38\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation><field name=\"function_name\">turnLeft</field><statement name=\"STACK\"><block type=\"CutebotPro_pwmCruiseControl\"><value name=\"speedL\"><shadow type=\"math_number\"><field name=\"NUM\">-40</field></shadow></value><value name=\"speedR\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">330</field></shadow></value><next><block type=\"CutebotPro_trolleySteering\"><field name=\"CutebotProTurn\">CutebotProTurn.LeftInPlace</field><value name=\"angle\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"360\" label=\"Angle\" precision=\"0\"></mutation><field name=\"SLIDER\">90</field></shadow></value></block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"0\" y=\"0\"><mutation name=\"getDistance\" functionid=\"GK`mzhe7zP4|3%r4.EHQ\"></mutation><field name=\"function_name\">getDistance</field><statement name=\"STACK\"><block type=\"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation><value name=\"RETURN_VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters</field></block></value></block></statement></block><block type=\"device_button_event\" x=\"-36\" y=\"164\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","main.py":"def isWall(distanceThreshold):\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS) < distanceThreshold\n\ndef turnLeft():\n    return\n\ndef turnRight():\n    return\n\ndef moveForward():\n    return\n\ndef navigateMaze(distanceThreshold, magnetThreshold):\n    '''\n    Navigating the maze is broken into four steps as follows:\n        1: Pathfinding through the maze until the bomb is found\n        2: Calculating an optimized path to the bomb\n        3: Reversing this path to optimize exiting\n        4: Exiting the maze\n    \n    Step 1 - Pathfinding Through the Maze:\n    The maze is navigated by always followling the left wall.\n    This works by prioritizing turning left, then going forward,\n        then turning right, and lastly backtracking.\n    The bot will turn left and then go through each direction until\n        it finds a direction it can go in.\n    Move is incremented with each turn to represent the direction the\n        bot goes, with the directions as follows:\n            1: Left turn\n            2: Forwards\n            3: Right turn\n            4: Backwards\n    These directions are stored to later be reported once the bomb is found.\n    '''\n    moves = [] # List to store past moves\n    # Navigate maze until magnet is found\n    while (input.magnetic_force(Dimension.X) < magnetThreshold):\n        # Check left direction first\n        turnLeft()\n        move = 1\n        # Turn right until open move found\n        while isWall(distanceThreshold):\n            turnRight()\n            move += 1 # Increment to track which direction is moved\n        moveForward() # Move forward to next square\n        moves.append(move) # Save direction moved to list\n    \n    '''\n    Step 2 - Calculating Optimized Path:\n    The move list is optimized by removing moves that lead towards dead ends.\n    Dead ends require the bot to turn around, represented by a 4 in the move list.\n    Duplicated moves leading up to these dead ends will add up to 4 as well.\n    The resultant move instead of turning towards the last end will be the sum\n        of the moves entering and exiting the dead end section.\n    '''\n    i = 0 # Loop through the list of moves\n    while i < len(moves):\n        if moves[i] == 4: # If the bot turned around on a certain move (reached a dead end)\n            j = 1\n            while (i - j) >= 0 and (i + j) < len(moves) and (moves[i - j] + moves[i + j]) == 4:\n                j += 1\n            newMoves = moves[:i - j]\n            newMoves.append(moves[i - j] + moves[i + j])\n            for k in range(i + j + 1, len(moves)):\n                newMoves.append(moves[k])\n            moves = newMoves\n            i = 0\n        i += 1\n    '''\n    Step 3 - Reversing Optimized Path \n    '''\n\n    '''\n    Step 4 - Exiting the Maze\n    '''\n    # Exit maze\n\n\ndef turnLeftTest():\n    CutebotPro.pwm_cruise_control(-40, 40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.LEFT_IN_PLACE, 90)\n\ndef turnRightTest():\n    CutebotPro.pwm_cruise_control(40, -40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.RIGHT_IN_PLACE, 90)\n\ndef moveForwardTest():\n    CutebotPro.pwm_cruise_control(40, 40)\n    CutebotPro.distance_running(CutebotProOrientation.ADVANCE, 40, CutebotProDistanceUnits.CM)\n\ndef moveBackwardsTest():\n    CutebotPro.pwm_cruise_control(-20, -20)\n    CutebotPro.distance_running(CutebotProOrientation.RETREAT, 40, CutebotProDistanceUnits.CM)\n\ndef on_button_pressed_a():\n    basic.show_leds(\"\"\"\n    # # # # #\n    # . . . #\n    # . . . #\n    # . . . #\n    # # # # #\n    \"\"\")\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # . . .\n        # # # # #\n        . # . . .\n        . . # . .\n        \"\"\")\n    turnLeftTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . . # .\n        # # # # #\n        . . . # .\n        . . # . .\n        \"\"\")\n    turnRightTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        \"\"\")\n    moveForwardTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . # . .\n        # . # . #\n        . # # # .\n        . . # . .\n        \"\"\")\n    moveBackwardsTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . . . .\n        # . # . #\n        # # . # #\n        # . . . #\n        # # # # #\n        \"\"\")\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n","pxt.json":"{\n    \"name\": \"Pathfinding\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-cutebotpro\": \"github:elecfreaks/pxt-cutebot-pro#v2.1.0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1743559607567,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"function_definition\" x=\"337\" y=\"-38\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation><field name=\"function_name\">turnLeft</field><statement name=\"STACK\"><block type=\"CutebotPro_pwmCruiseControl\"><value name=\"speedL\"><shadow type=\"math_number\"><field name=\"NUM\">-40</field></shadow></value><value name=\"speedR\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">330</field></shadow></value><next><block type=\"CutebotPro_trolleySteering\"><field name=\"CutebotProTurn\">CutebotProTurn.LeftInPlace</field><value name=\"angle\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"360\" label=\"Angle\" precision=\"0\"></mutation><field name=\"SLIDER\">90</field></shadow></value></block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"0\" y=\"0\"><mutation name=\"getDistance\" functionid=\"GK`mzhe7zP4|3%r4.EHQ\"></mutation><field name=\"function_name\">getDistance</field><statement name=\"STACK\"><block type=\"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation><value name=\"RETURN_VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters</field></block></value></block></statement></block><block type=\"device_button_event\" x=\"-36\" y=\"164\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","main.py":"def isWall(distanceThreshold):\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS) < distanceThreshold\n\ndef turnLeft():\n    return\n\ndef turnRight():\n    return\n\ndef moveForward():\n    return\n\ndef navigateMaze(distanceThreshold, magnetThreshold):\n    '''\n    Navigating the maze is broken into four steps as follows:\n        1: Pathfinding through the maze until the bomb is found\n        2: Calculating an optimized path to the bomb\n        3: Reversing this path to optimize exiting\n        4: Exiting the maze\n    \n    Step 1 - Pathfinding Through the Maze:\n    The maze is navigated by always followling the left wall.\n    This works by prioritizing turning left, then going forward,\n        then turning right, and lastly backtracking.\n    The bot will turn left and then go through each direction until\n        it finds a direction it can go in.\n    Move is incremented with each turn to represent the direction the\n        bot goes, with the directions as follows:\n            1: Left turn\n            2: Forwards\n            3: Right turn\n            4: Backwards\n    These directions are stored to later be reported once the bomb is found.\n    '''\n    moves = [] # List to store past moves\n    # Navigate maze until magnet is found\n    while (input.magnetic_force(Dimension.X) < magnetThreshold):\n        # Check left direction first\n        turnLeft()\n        move = 1\n        # Turn right until open move found\n        while isWall(distanceThreshold):\n            turnRight()\n            move += 1 # Increment to track which direction is moved\n        moveForward() # Move forward to next square\n        moves.append(move) # Save direction moved to list\n    \n    '''\n    Step 2 - Calculating Optimized Path:\n    The move list is optimized by removing moves that lead towards dead ends.\n    Dead ends require the bot to turn around, represented by a 4 in the move list.\n    Duplicated moves leading up to these dead ends will add up to 4 as well.\n    The resultant move instead of turning towards the last end will be the sum\n        of the moves entering and exiting the dead end section.\n    '''\n    i = 0 # Loop through the list of moves\n    while i < len(moves):\n        if moves[i] == 4: # If the bot turned around on a certain move (reached a dead end)\n            j = 1 # Use a second loop to find extent of dead end path\n            while (i - j) >= 0 and (i + j) < len(moves) and (moves[i - j] + moves[i + j]) == 4:\n                j += 1\n            newMoves = moves[:i - j]\n            newMoves.append(moves[i - j] + moves[i + j])\n            for k in range(i + j + 1, len(moves)):\n                newMoves.append(moves[k])\n            moves = newMoves\n            i = 0\n        i += 1\n\n    '''\n    Step 3 - Reversing Optimized Path\n    Reversing the optimized path can be done by first reversing the order of\n        the optimized path from the previous step and then subtracting each\n        element from 4 to find the opposite of each of the steps taken.\n    '''\n    exitMoves = []\n    for i in range(len(moves)):\n        exitMoves.append(4 - moves[len(moves) - i - 1])\n\n    '''\n    Step 4 - Exiting the Maze\n    The bot can exit the maze by turning around, moving forwards, then\n        simply following the list of exit moves.\n    '''\n    # Exit maze\n    turnRight()\n    turnRight()\n    moveForward()\n    \n\n\ndef turnLeftTest():\n    CutebotPro.pwm_cruise_control(-40, 40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.LEFT_IN_PLACE, 90)\n\ndef turnRightTest():\n    CutebotPro.pwm_cruise_control(40, -40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.RIGHT_IN_PLACE, 90)\n\ndef moveForwardTest():\n    CutebotPro.pwm_cruise_control(40, 40)\n    CutebotPro.distance_running(CutebotProOrientation.ADVANCE, 40, CutebotProDistanceUnits.CM)\n\ndef moveBackwardsTest():\n    CutebotPro.pwm_cruise_control(-20, -20)\n    CutebotPro.distance_running(CutebotProOrientation.RETREAT, 40, CutebotProDistanceUnits.CM)\n\ndef on_button_pressed_a():\n    basic.show_leds(\"\"\"\n    # # # # #\n    # . . . #\n    # . . . #\n    # . . . #\n    # # # # #\n    \"\"\")\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # . . .\n        # # # # #\n        . # . . .\n        . . # . .\n        \"\"\")\n    turnLeftTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . . # .\n        # # # # #\n        . . . # .\n        . . # . .\n        \"\"\")\n    turnRightTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        \"\"\")\n    moveForwardTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . # . .\n        # . # . #\n        . # # # .\n        . . # . .\n        \"\"\")\n    moveBackwardsTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . . . .\n        # . # . #\n        # # . # #\n        # . . . #\n        # # # # #\n        \"\"\")\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n","pxt.json":"{\n    \"name\": \"Pathfinding\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-cutebotpro\": \"github:elecfreaks/pxt-cutebot-pro#v2.1.0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}},{"timestamp":1743561655163,"editorVersion":"7.0.57","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"function_definition\" x=\"337\" y=\"-38\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation><field name=\"function_name\">turnLeft</field><statement name=\"STACK\"><block type=\"CutebotPro_pwmCruiseControl\"><value name=\"speedL\"><shadow type=\"math_number\"><field name=\"NUM\">-40</field></shadow></value><value name=\"speedR\"><shadow type=\"math_number\"><field name=\"NUM\">40</field></shadow></value><next><block type=\"CutebotPro_angleRunning\"><field name=\"CutebotProWheel\">CutebotProWheel.AllWheel</field><field name=\"CutebotProAngleUnits\">CutebotProAngleUnits.Angle</field><value name=\"angle\"><shadow type=\"math_number\"><field name=\"NUM\">330</field></shadow></value><next><block type=\"CutebotPro_trolleySteering\"><field name=\"CutebotProTurn\">CutebotProTurn.LeftInPlace</field><value name=\"angle\"><shadow type=\"math_number_minmax\"><mutation min=\"0\" max=\"360\" label=\"Angle\" precision=\"0\"></mutation><field name=\"SLIDER\">90</field></shadow></value></block></next></block></next></block></statement></block><block type=\"function_definition\" x=\"0\" y=\"0\"><mutation name=\"getDistance\" functionid=\"GK`mzhe7zP4|3%r4.EHQ\"></mutation><field name=\"function_name\">getDistance</field><statement name=\"STACK\"><block type=\"function_return\"><mutation xmlns=\"http://www.w3.org/1999/xhtml\" no_return_value=\"false\"></mutation><value name=\"RETURN_VALUE\"><shadow type=\"math_number\"><field name=\"NUM\">0</field></shadow><block type=\"ultrasonic\"><field name=\"SonarUnit\">SonarUnit.Centimeters</field></block></value></block></statement></block><block type=\"device_button_event\" x=\"-36\" y=\"164\"><field name=\"NAME\">Button.A</field><statement name=\"HANDLER\"><block type=\"function_call\"><mutation name=\"turnLeft\" functionid=\"Vz5/;1m(W;THC`HkdqP2\"></mutation></block></statement></block></xml>","main.ts":"","README.md":"","main.py":"def isWall(distanceThreshold):\n    return CutebotPro.ultrasonic(SonarUnit.CENTIMETERS) < distanceThreshold\n\ndef turnLeft():\n    return\n\ndef turnRight():\n    return\n\ndef moveForward():\n    return\n\ndef navigateMaze(distanceThreshold, magnetThreshold):\n    '''\n    Navigating the maze is broken into four steps as follows:\n        1: Pathfinding through the maze until the bomb is found\n        2: Calculating an optimized path to the bomb\n        3: Reversing this path to optimize exiting\n        4: Exiting the maze\n    \n    Step 1 - Pathfinding Through the Maze:\n    The maze is navigated by always followling the left wall.\n    This works by prioritizing turning left, then going forward,\n        then turning right, and lastly backtracking.\n    The bot will turn left and then go through each direction until\n        it finds a direction it can go in.\n    Move is incremented with each turn to represent the direction the\n        bot goes, with the directions as follows:\n            1: Left turn\n            2: Forwards\n            3: Right turn\n            4: Backwards\n    These directions are stored to later be reported once the bomb is found.\n    '''\n    moves = [] # List to store past moves\n    # Navigate maze until magnet is found\n    while (input.magnetic_force(Dimension.X) < magnetThreshold):\n        # Check left direction first\n        turnLeft()\n        move = 1\n        # Turn right until open move found\n        while isWall(distanceThreshold):\n            turnRight()\n            move += 1 # Increment to track which direction is moved\n        moveForward() # Move forward to next square\n        moves.append(move) # Save direction moved to list\n    \n    '''\n    Step 2 - Calculating Optimized Path:\n    The move list is optimized by removing moves that lead towards dead ends.\n    Dead ends require the bot to turn around, represented by a 4 in the move list.\n    Duplicated moves leading up to these dead ends will add up to 4 as well.\n    The resultant move instead of turning towards the last end will be the sum\n        of the moves entering and exiting the dead end section.\n    '''\n    i = 0 # Loop through the list of moves\n    while i < len(moves):\n        if moves[i] == 4: # If the bot turned around on a certain move (reached a dead end)\n            j = 1 # Use a second loop to find extent of dead end path\n            while (i - j) >= 0 and (i + j) < len(moves) and (moves[i - j] + moves[i + j]) == 4:\n                j += 1 # Increment j to move on to next pair of values\n            # Build new list of moves with dead ends filtered out\n            newMoves = moves[:i - j] # Moves before dead end\n            newMoves.append(moves[i - j] + moves[i + j]) # Move made of combined moves entering and leaving dead end\n            for k in range(i + j + 1, len(moves)): # Moves after dead end\n                newMoves.append(moves[k])\n            moves = newMoves\n            i = 0 # Length and index of list changes. I could calculate the new list but its easier to just start at the beginning again.\n        i += 1 # Increment i to move on to next index\n\n    '''\n    Step 3 - Reversing Optimized Path\n    Reversing the optimized path can be done by first reversing the order of\n        the optimized path from the previous step and then subtracting each\n        element from 4 to find the opposite of each of the steps taken.\n    '''\n    exitMoves = []\n    for i in range(len(moves)):\n        exitMoves.append(4 - moves[len(moves) - i - 1])\n\n    '''\n    Step 4 - Exiting the Maze\n    The bot can exit the maze by turning around, moving forwards, then\n        simply following the list of exit moves.\n    '''\n    # Exit maze\n    turnRight()\n    turnRight()\n    moveForward()\n    for i in range(len(exitMoves)):\n        if i == 1:\n            turnLeft()\n        elif i == 2:\n            moveForward()\n        else:\n            turnRight()\n    moveForward()\n\n\ndef turnLeftTest():\n    CutebotPro.pwm_cruise_control(-40, 40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.LEFT_IN_PLACE, 90)\n\ndef turnRightTest():\n    CutebotPro.pwm_cruise_control(40, -40)\n    CutebotPro.angle_running(CutebotProWheel.ALL_WHEEL, 330, CutebotProAngleUnits.ANGLE)\n    # CutebotPro.trolley_steering(CutebotProTurn.RIGHT_IN_PLACE, 90)\n\ndef moveForwardTest():\n    CutebotPro.pwm_cruise_control(40, 40)\n    CutebotPro.distance_running(CutebotProOrientation.ADVANCE, 40, CutebotProDistanceUnits.CM)\n\ndef moveBackwardsTest():\n    CutebotPro.pwm_cruise_control(-20, -20)\n    CutebotPro.distance_running(CutebotProOrientation.RETREAT, 40, CutebotProDistanceUnits.CM)\n\ndef on_button_pressed_a():\n    basic.show_leds(\"\"\"\n    # # # # #\n    # . . . #\n    # . . . #\n    # . . . #\n    # # # # #\n    \"\"\")\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # . . .\n        # # # # #\n        . # . . .\n        . . # . .\n        \"\"\")\n    turnLeftTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . . # .\n        # # # # #\n        . . . # .\n        . . # . .\n        \"\"\")\n    turnRightTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . # # # .\n        # . # . #\n        . . # . .\n        . . # . .\n        \"\"\")\n    moveForwardTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . # . .\n        . . # . .\n        # . # . #\n        . # # # .\n        . . # . .\n        \"\"\")\n    moveBackwardsTest()\n    basic.pause(1000)\n    basic.show_leds(\"\"\"\n        . . . . .\n        # . # . #\n        # # . # #\n        # . . . #\n        # # # # #\n        \"\"\")\n\ninput.on_button_pressed(Button.A, on_button_pressed_a)\n","pxt.json":"{\n    \"name\": \"Pathfinding\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"pxt-cutebotpro\": \"github:elecfreaks/pxt-cutebot-pro#v2.1.0\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"main.py\"\n    ],\n    \"preferredEditor\": \"pyprj\"\n}\n"}}],"shares":[],"lastSaveTime":1743561767627}